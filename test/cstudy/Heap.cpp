#define _CRT_SECURE_NO_WARNINGS 1
 
//包含堆头文件：
#include "Heap.h"
 
//堆初始化函数1 -- 对堆类型中的成员进行初始化
// （一开始不给值，之后使用函数插入值形成堆）
//接收 堆类型指针（php）
void HeapInit(HP* php)
{
	//assert断言接收的堆类型指针不为空：
	//(确保有成功创建堆类型可以被初始化）
	assert(php);
 
	//将堆根节点指针置为NULL：
	php->a = NULL;
	//将堆当前节点个数置为0：
	php->size = 0;
	//将堆当前开辟的空间单位置为0：
	php->capacity = 0;
}
 
 
 
//堆销毁函数 -- 对堆类型进行销毁
//接收 堆类型指针（php）
void HeapDestroy(HP* php)
{
	//assert断言接收的堆类型指针不为空：
	//确保有堆类型可以被销毁
	assert(php);
 
	//释放堆类型中以a为头开辟的动态空间：
	free(php->a);
 
	//将堆当前节点个数和堆当前开辟的空间单位置为0：
	php->a = NULL;
	php->size = php->capacity = 0;
}
 
 
 
//打印堆函数 -- 打印堆中各节点值
//接收 堆类型指针（php）
void HeapPrint(HP* php)
{
	//assert断言接收的堆类型指针不为空：
	//(确保有成功创建堆类型可以被打印）
	assert(php);
 
	//使用for循环循环打印：
	for (int i = 0; i < php->size; i++)
		//size有多少个节点就打印多少个节点值：
	{
		//通过下标打印节点值：
		printf("%d ", php->a[i]);
	}
 
	//换行：
	printf("\n");
}
 
 
 
//节点位置互换函数 -- 在向上向下调整操作中互换节点位置：
//接收要互换位置的两个节点的指针（p1 和 p2）
void Swap(HPDataType* p1, HPDataType* p2)
{
	//创建一个临时变量配合调换两节点值：
	HPDataType tmp = *p1;
	*p1 = *p2;
	*p2 = tmp;
}
 
 
 
//在内部实现一个不对外声明的向上调整函数AdjustUp
//第一个参数接收 堆底层数组的首元素地址
//第二个参数接收 刚刚插入数组元素(子节点)的下标
void AdjustUp(HPDataType* a, int child)
{
	//使用之前讲到的公式，
	//通过子节点下标找到其父节点下标：
	int parent = (child - 1) / 2;
 
	//只要child还大于0就继续向上调整
	//需要向上层调整的话，上层节点的下标是比较小的
	//所以child不断调整就会越来越小
	while (child > 0)
	{
		//小堆中的向上调整：
		if (a[child] < a[parent])
			//小堆中子节点值比父节点值还小:
		//大堆中则把条件改为：
		//if (a[child] > a[parent])  //大堆的向上调整
		{
			//那就需要两者调换位置:
			Swap(&a[child], &a[parent]); 
 
			//值替换成功后，下标也要进行调整：
			//child移到上层后，下标为parent下标：
			child = parent;
 
			//child移到该层后，还可能是再上层父节点的子节点
			//可能还需要再向上调整，最坏的情况是移到成为堆的根节点：
			
			//再获得新父节点的下标：
			parent = (parent - 1) / 2;
		}
		else
			//如果小堆中子节点值已经大于等于父节点值了
			//即符合小堆的条件了
		{
			//那就不用进行向上调整，break退出循环：
			break;
		}
	}
}
 
//堆插入函数 -- 在堆类型中插入一个节点
//接收 堆类型指针（php）和插入节点的值（x）
void HeapPush(HP* php, HPDataType x)
{
	//assert断言接收的堆类型指针不为空：
	//确保有堆类型可以插入节点
	assert(php);
 
	//断言后要检查是否需要扩容：
	if (php->size == php->capacity)
		//堆当前节点个数 == 开辟空间单位
		//说明插入节点前需先进行扩容：
	{
		//创建变量存储新容量单位：
		int newCapacity = php->capacity == 0 ? 4 : php->capacity * 2;
		//因为capacity初始化为0，所以可以使用三目操作符进行增容：
		//ps->capacity == 0 ? 4 : ps->capacity * 2
		//如果为0则直接增容到4，不为0则增容2倍
 
		//开辟动态空间：
		HPDataType* tmp = (HPDataType*)realloc(php->a, sizeof(HPDataType) * newCapacity);
		//这里直接使用realloc函数进行动态空间开辟
		//如果realloc函数接收头指针（该函数第一个参数）为空，
		//那么它的作用相当于malloc函数
 
		//对开辟空间进行检查：
		if (tmp == NULL)
			//返回空指针，开辟失败：
		{
			//打印错误信息：
			perror("realloc fail");
			//终止程序：
			exit(-1);
		}
		
		//成功开辟空间后，将开辟空间的头指针赋给a：
		php->a = tmp;
		//将新容量单位赋给原容量单位：
		php->capacity = newCapacity;
	}
 
	//在堆中进行插入操作：
 
//堆：
//物理结构是个数组；逻辑结构是个树
//树就没有头插和尾插的概念了
//节点具体插入哪个位置要看情况
//只要插入值足够大或足够小，就可以一直往上一层替换
//节点插入堆后要保持还是一个堆，是从左到右连续的树
 
	//不论什么情况，先默认插入最尾部：
	//（即堆底层数组的末尾）
	//因为数组下标从0开始，
	//所以size即末尾插入节点下标：
	php->a[php->size] = x;
 
	//插入后堆当前节点个数size++：
	php->size++;
 
	//此时如果插入节点足够大（或足够小），
	//则刚好满足大堆（或小堆）的条件，
	//但如果不满足，就要将插入节点向树的上层调整,
	//且之后还会再执行该操作，
	//所以这里可以在文件内部定义一个向上调整函数AdjustUp
	//并进行调用：
	AdjustUp(php->a, php->size-1);
	//第一个参数接收 堆底层数组的首元素地址
	//第二个参数接收 刚刚插入数组元素(子节点)的下标
	// php->size-1 -- 前面插入节点后size++了
	// 所以这里的下标应-1 ，得到插入元素下标
}
 
 
 
//堆初始化函数2 -- 接收一个数组将其初始化为一个堆底层数组
// （给你底层数组的各个值，再向上调整形成堆）
//接收 堆类型指针（php）、数组首元素地址（a）、数组元素个数（n）
void HeapInitArray(HP* php, int* a, int n)
{
	//assert断言断言接收的堆类型指针不为空：
	//(确保有成功创建堆类型可以被初始化）
	assert(php);
	//assert断言数组a不为空：
	assert(a);
 
	//开辟动态空间：
	php->a = (HPDataType*)malloc(sizeof(HPDataType*) * n);
	//对开辟空间进行检查：
	if (php->a == NULL)
		//返回空指针，开辟失败：
	{
		//打印错误信息：
		perror("realloc fail");
		//终止程序：
		exit(-1);
	}
 
	//将堆当前节点个数置为n：
	php->size = n;
	//将堆当前开辟的空间单位置为n：
	php->capacity = n;
 
	//将数组元素拷贝作为堆底层数组元素：
	memcpy(php->a, a, sizeof(HPDataType) * n);
 
	//再循环向上调整堆中的节点（底层数组元素）进行建堆 ：
	for (int i = 1; i < n; i++)
	{
		AdjustUp(php->a, i);
	}
}
 
 
 
//在内部实现一个不对外声明的向下调整函数AdjustDown
//第一个参数接收 堆底层数组的首元素地址
//第二个参数接收 堆节点个数(底层数组元素个数)
//第三个参数接收 调换位置后的根节点（原尾节点）下标
void AdjustDown(HPDataType* a, int n, int parent)
{
	//（小堆中）向下调整需要获得比父节点parent小的子节点：
	// （该子节点要和其父节点调换位置）
 
	//可以先假设左子节点是比父节点小的：
	//获得根节点的左子节点（第一个子节点）下标：
	int child = parent * 2 + 1;
 
	//最坏情况：根节点成为叶子(没有子节点可以替换了)
	while (child < n)
		//左子节点下标如果>=堆节点个数(底层数组元素个数)
		//说明已经超出了数组范围，此时父节点已成为叶子无法再调换
	{
		//如果我们上面假设是错的：
		if (child + 1 < n  &&  a[child + 1] < a[child])
		//大堆中则把条件改为：
		//if (child + 1 < n  &&  a[child + 1] > a[child]) //大堆的向下调整
			// child+1 即右子节点的下标
				/*	左右子节点都存在才用比较出较小节点：	
				防止不存在的右子节点越界：child + 1 < n
				上面只要左子节点在数组就能进入while循环
				而左子节点可能就是数组最后一个元素了
				可能会出现左子节点存在而右子节点不存在的情况
				所以要在右子节点存在的情况下比较出较小节点
				/没有右子节点直接使用左子节点。
				*/
			//如果右子节点比左子节点小：
		{
			//就要获得右子节点（较小子节点）下标：
			++child; //自增后即右子节点下标
		}
 
		//到这里就获得较小节点的下标：
		//（不关心是左子节点还是右子节点，只要值小的节点）
 
		//（小堆中）如果较小节点比父节点还小
		if (a[child] < a[parent])
		//大堆中则把条件改为：
		//if (a[child] > a[parent]) //大堆的向下调整
		{
			//那就需要调换两者位置：
			Swap(&a[child], &a[parent]);
 
			//调换两节点值后，下标也要刷新：
			parent = child;
 
			//此时新的子节点下标为：
			child = parent * 2 + 1;
		}
		else
			//如果较小节点已经比父节点大了：
		{
			//那就符合小堆的条件，没必要调换：
			break; //退出循环
		}
		
	}
}
 
//堆删除函数 -- 删除堆类型根节点（删除当前堆中最值）
//接收 堆类型指针（php）
void HeapPop(HP* php)
{
	//assert断言接收的堆类型指针不为空：
	//确保有堆类型可以删除根节点
	assert(php);
	//assert断言堆节点个数（底层数组元素个数）不为0
	//确保有节点可以删除：
	assert(php->size > 0);
 
		/*
		如果进行挪动覆盖第一个位置的根节点
		会导致剩下的节点关系乱套（兄弟变父子）
		最终结果可能不一定是堆，
		而且数组中挪动覆盖效率本来就不高
		所以可以将根节点和尾节点交换位置
		再进行尾删，就实现了删除根节点
		且数组中尾删效率较高，
		*/
 
	//将根节点值和尾节点值交换:
	Swap(&php->a[0], &php->a[php->size - 1]);
	//	&php->a[0] ：根节点值
	//	&php->a[php->size - 1] ：尾结点值
 
	//再将移至尾部的原根节点删除：
	--php->size; //直接元素个数size-1即可
	
		/*
		此时堆的左右子树的结构没有变化
		左右子树依然是小堆（大堆）
		有了这个前提就可以进行向下调整：
		因为前面根节点和尾节点交换位置
		所以现在的根节点（原尾结点）可能就要比起子节点大了
		树整体不符合小堆条件，所以要进行向下调整
		（注：向上调整的前提是前面节点符合堆的条件）
		向下调整操作：
		成为根节点后，跟其两个子节点比较
		如果子节点比较小，则互换位置
		互换位置后再跟下一层子节点比较
		如果子节点比较小，则互换位置
		以此类推，最坏情况是到成为叶子为止
		（小堆中大的值往下移，小的值往上走）
		*/
 
	//所以这里可以在文件内部定义一个向下调整函数AdjustDown
	//并进行调用：
	AdjustDown(php->a, php->size, 0);
	//根节点在底层数组中下标是0
 
		/*
		* 该函数的意义和示例：
		该函数的意义是删除第一小的值（小堆中）
		再找到第二小的值，以此类推，可以依次找到数组的最小值
		示例：“该城市排名前10的蛋糕店” 小堆根元素就第一好的店，
		使用该函数后找到第二好的店，以此类推……
		*/
	
		/*
		* 该函数时间复杂度：
		向下或向上调整操作最好情况执行1次，最坏情况执行树的高度次
		即时间复杂度为 O(logN)，10亿个值只需调整30多次 -- 很优秀
		 （ log -- 默认以2为底 ）
		*/
 
}
 
 
 
//堆顶函数 -- 获取并返回推根节点值
//接收 堆类型指针（php）
HPDataType HeapTop(HP* php)
{
	//assert断言接收的堆类型指针不为空：
	//确保有堆类型可以获取根节点值
	assert(php);
	//assert断言堆节点个数（底层数组元素个数）不为0
	//确保堆类型中有节点：
	assert(php->size > 0);
 
	//直接返回根节点值：
	return php->a[0];
}
 
 
 
//判空函数 -- 判断堆类型是否为空
//接收 堆类型指针（php）
bool HeapEmpty(HP* php)
{
	//assert断言接收的堆类型指针不为空：
	//确保有堆类型可以获取根节点值
	assert(php);
 
	//如果堆节点个数（底层数组元素个数）为0则说明堆为空：
	return php->size == 0;
	//php->size = 0 -- 成立返回true，堆为空
	//php->size = 0 -- 不成立返回false，堆不为空 
}